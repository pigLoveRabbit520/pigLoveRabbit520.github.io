<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Go - 标签 - 猪爱兔的网站</title><link>https://pigLoveRabbit520.github.io/tags/go/</link><description>Go - 标签 - 猪爱兔的网站</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 15 Jun 2020 20:00:00 +0000</lastBuildDate><atom:link href="https://pigLoveRabbit520.github.io/tags/go/" rel="self" type="application/rss+xml"/><item><title>go并发之WaitGroup使用</title><link>https://pigLoveRabbit520.github.io/go_sync_waitgroup/</link><pubDate>Mon, 15 Jun 2020 20:00:00 +0000</pubDate><author>Salamander</author><guid>https://pigLoveRabbit520.github.io/go_sync_waitgroup/</guid><description><![CDATA[<h2 id="需求">需求</h2>
<p>有时候我们会开启很多线程（go中是协程）去做一件事件，然后希望主线程等待这些线程都完成后才结束，一个简单的想法是，我在主线程sleep一段时间，譬如3s钟，但是明显这样的做法不科学，因为这些任务很有可能在200ms内就都完成了。如果你用过Java的话，那你很快就会想到<code>CountDownLatch</code>类，在Go中，也有类似的结构，就是本文要讨论的<code>WaitGroup</code>。</p>]]></description></item><item><title>gRPC入门使用</title><link>https://pigLoveRabbit520.github.io/grpc_learn/</link><pubDate>Tue, 02 Jun 2020 09:00:00 +0000</pubDate><author>Salamander</author><guid>https://pigLoveRabbit520.github.io/grpc_learn/</guid><description><![CDATA[<h2 id="grpc是什么">gRPC是什么</h2>
<p><a href="https://grpc.io" target="_blank" rel="noopener noreffer ">官网</a>如此写到</p>
<blockquote>
<p>A high-performance, open source universal RPC framework</p>
</blockquote>
<p>其实，gRPC是一个高性能的，通用的，面向服务端和移动端，基于 HTTP/2 设计的RPC框架。</p>
<!-- more -->
<h2 id="rpc框架是什么">RPC框架是什么？</h2>
<p>RPC 框架说白了就是让你可以像调用本地方法一样调用远程服务提供的方法，而不需要关心底层的通信细节。简单地说就让远程服务调用更加简单、透明。
RPC框架包含了客户端（Client）和服务端（Server）<br>
常见的RPC框架有</p>]]></description></item></channel></rss>