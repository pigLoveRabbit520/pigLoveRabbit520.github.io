<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Java - 标签 - pigLoveRabbit的网站</title><link>https://example.com/tags/java/</link><description>Java - 标签 - pigLoveRabbit的网站</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 21 Apr 2020 16:00:00 +0000</lastBuildDate><atom:link href="https://example.com/tags/java/" rel="self" type="application/rss+xml"/><item><title>Elasticsearch简单使用</title><link>https://example.com/elasticsearch_to_know/</link><pubDate>Tue, 21 Apr 2020 16:00:00 +0000</pubDate><author>Salamander</author><guid>https://example.com/elasticsearch_to_know/</guid><description><![CDATA[<p></p>
<h2 id="elasticsearch">Elasticsearch</h2>
<p><code>Elasticsearch</code>是一个基于Lucene的搜索服务器（Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库）。Elasticsearch使用Java编写并使用Lucene来建立索引并实现搜索功能，但是它的目的是通过简单连贯的<code>RESTful API</code>让全文搜索变得简单并隐藏Lucene的复杂性。</p>]]></description></item><item><title>Java经典回顾之Java Web</title><link>https://example.com/java_lookback_java-web/</link><pubDate>Thu, 09 Apr 2020 21:00:00 +0000</pubDate><author>Salamander</author><guid>https://example.com/java_lookback_java-web/</guid><description><![CDATA[<p></p>
<p>本文环境：</p>
<ul>
<li>OS：Ubuntu 18.04.4 LTS</li>
<li>Java版本：1.8.0_221</li>
</ul>
<h2 id="java-web">Java Web</h2>
<p>虽然我们现在会用<code>SpringBoot</code>快速创建一个Web Demo，但是基础不能忘（<code>SpringBoot</code>或者<code>SpringMVC</code>都是封装后的产物），下面就让我们回顾一下一个最基本的Java Web项目。</p>]]></description></item><item><title>Java之GC</title><link>https://example.com/java_gc/</link><pubDate>Wed, 01 Apr 2020 09:00:00 +0000</pubDate><author>Salamander</author><guid>https://example.com/java_gc/</guid><description><![CDATA[<p></p>
<h2 id="gc">GC</h2>
<p>GC就是垃圾回收（<code>Garbage Collection</code>），如果你写过C++或者C程序的，你就会知道<code>new</code>一个数据后，就需要<code>delete</code>它的内存，这就是手动管理内存，但这样如果你粗心点的话，就容易造成内存泄露，所以就有了自动垃圾回收，也就我们这里所讨论的GC。Java的GC会对JVM（Java Virtual Machine）中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，永不停息（Nerver Stop）的保证JVM中的内存空间，防止出现内存泄露和溢出问题。<br>
其实GC很早就有了，1960年诞生于MIT的<strong>Lisp</strong>是第一门真正使用内存动态分配和垃圾收集技术的语言。</p>]]></description></item><item><title>基于Zookeeper的分布式锁</title><link>https://example.com/zookeeper_cluster_lock/</link><pubDate>Thu, 12 Mar 2020 16:00:00 +0000</pubDate><author>Salamander</author><guid>https://example.com/zookeeper_cluster_lock/</guid><description>
&lt;p>Zookeeper 是 Apache 的一个顶级项目，为分布式应用提供高效、高可用的分布式协调服务，提供了诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知和分布式锁等分布式基础服务。
由于 ZooKeeper 便捷的使用方式、卓越的性能和良好的稳定性，被广泛地应用于诸如 Hadoop、HBase、Kafka 和 Dubbo 等大型分布式系统中。&lt;/p></description></item><item><title>Java之synchronized的实现原理</title><link>https://example.com/java_synchronized_underlying/</link><pubDate>Tue, 25 Feb 2020 19:00:00 +0000</pubDate><author>Salamander</author><guid>https://example.com/java_synchronized_underlying/</guid><description><![CDATA[<h2 id="synchronized">synchronized</h2>
<p>在Java多线程编程中，我们最先碰到的也是最简单的方法就利用<code>synchronized</code>关键字。用它的方式有三种：</p>
<ul>
<li>修饰实例方法，锁是当前实例对象</li>
<li>修饰静态方法，锁是当前类的class对象（每个类都有一个Class对象）</li>
<li>修饰代码块，锁定括号里的对象</li>
</ul>
<p>加上<code>synchronized</code>之后，我们的代码就变成了同步代码，神奇又强大，但有的时候也不禁会思考下：Java底层是怎么实现<code>synchronized</code>关键字的？<br>
在阅读了一些文章之后，我在这里做了一些归纳和总结。</p>]]></description></item></channel></rss>