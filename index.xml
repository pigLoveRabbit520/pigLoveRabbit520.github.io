<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>pigLoveRabbit的网站</title><link>https://example.com/</link><description>Javascript NodeJs C# software developer</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 08 Oct 2024 14:00:00 +0000</lastBuildDate><atom:link href="https://example.com/index.xml" rel="self" type="application/rss+xml"/><item><title>最小二乘法和线性回归</title><link>https://example.com/least_square/</link><pubDate>Tue, 08 Oct 2024 14:00:00 +0000</pubDate><author>pigLoveRabbit</author><guid>https://example.com/least_square/</guid><description><![CDATA[<h2 id="最小二乘法">最小二乘法</h2>
<p>早在19世纪,勒让德就认为让&quot;误差的平方和最小&quot;估计出来的模型是最接近真实情形的。<br>
按照勒让德的最佳原则,于是就是求:<br>
$$
\text{L} = \sum_{i=1}^{n} \left( y_i - f(x_i) \right)^2
$$
这个目标函数取得最小值时的函数参数,这就是最小二乘法的思想想,所谓&quot;二乘&quot;就是平方的意思。从这里我们可以看到,<strong>最小二乘法其实
就是用来做函数拟合的一种思想</strong>。<br>
至于怎么求出具体的参数那就是另外一个问题了,理论上可以用导数法、几何法,工程上可以用<strong>梯度下降法</strong>。下面以最常用的线性回归为
例进行推导和理解。<br>
在<strong>机器学习</strong>中用于回归问题的损失函数(Loss Function)是均方误差(MSE)：
$$
\text{L} = \frac{1}{2n} \sum_{i=1}^{n} \left( y_i - f(x_i) \right)^2
$$
其实就是多了个1/2n。</p>]]></description></item><item><title>JavaScript中的微任务、宏任务和Promise</title><link>https://example.com/javascript_%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97_promise/</link><pubDate>Wed, 18 Sep 2024 09:00:00 +0000</pubDate><author>pigLoveRabbit</author><guid>https://example.com/javascript_%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97_promise/</guid><description>&lt;p>JavaScript会将异步任务划分为微任务和宏任务，微任务会在宏任务之前执行（因为每次从主线程切换到任务队列时，都会优先遍历微任务队列，后遍历宏任务队列）。&lt;/p></description></item><item><title>Ubuntu上OptiX8 简单尝试</title><link>https://example.com/ubuntu-optix-8%E7%AE%80%E5%8D%95%E5%B0%9D%E8%AF%95/</link><pubDate>Fri, 05 Jul 2024 16:00:00 +0000</pubDate><author>pigRabbit</author><guid>https://example.com/ubuntu-optix-8%E7%AE%80%E5%8D%95%E5%B0%9D%E8%AF%95/</guid><description><![CDATA[<p>CUDA 的安装参考之前的<a href="/wsl2-install-cuda/" rel="">文章</a><br>
需要安装 <a href="https://developer.nvidia.com/designworks/optix/download" target="_blank" rel="noopener noreffer ">OptiX 8</a><br>
这是<a href="https://raytracing-docs.nvidia.com/optix8/api/OptiX_API_Reference.pdf" target="_blank" rel="noopener noreffer ">Reference.pdf</a></p>
<p>新建一个 CMake 项目，目录结构是这样的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">optix_example/
</span></span><span class="line"><span class="cl">├── CMakeLists.txt
</span></span><span class="line"><span class="cl">├── src
</span></span><span class="line"><span class="cl">    └── main.cpp
</span></span><span class="line"><span class="cl">└── cmake
</span></span><span class="line"><span class="cl">    └── FindOptiX80.cmake
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>CMakeLists.txt</code>文件：</p>]]></description></item><item><title>二维异形件排版算法（摘抄）</title><link>https://example.com/irregular_packing_nesting_problem/</link><pubDate>Thu, 15 Feb 2024 16:00:00 +0000</pubDate><author>pigLoveRabbit</author><guid>https://example.com/irregular_packing_nesting_problem/</guid><description>&lt;h3 id="算法简介">算法简介&lt;/h3>
&lt;p>排样问题（Nesting Problem）又称为下料问题(Cutting and stock problems)或填充问题(Packing Problem)，其目标是在材料切割过程中寻找一个较高的材料利用率。排样问题属于经典的NP-Hard问题，其时间复杂度随着问题规模的增加迅速上升，难以在合理时间内精确求解大规模实例。相较于矩形排样问题，异形件排样问题的突出特点是裁片的边界轮廓复杂，计算过程中需要复杂的几何运算，其算法复杂度将进一步上升，是学术界和工业界公认的难以求解的问题。因此在大多数情况下，不规则形状排样算法主要是以启发式算法和智能搜索算法为主。&lt;/p></description></item><item><title>wsl2 install CUDA</title><link>https://example.com/wsl2-install-cuda/</link><pubDate>Sun, 10 Dec 2023 16:00:00 +0000</pubDate><author>pigLoveRabbit</author><guid>https://example.com/wsl2-install-cuda/</guid><description><![CDATA[<h5 id="驱动">驱动</h5>
<p>网上有许多资料写道需要安装针对WSL特别驱动，但是现在已经不需要这么做了，只需要到NVIDIA官网将<a href="https://www.nvidia.com/Download/index.aspx" target="_blank" rel="noopener noreffer ">驱动</a>升级到最新版本即可。根据参考资料描述，驱动类型最好选择Game Ready版本而不是studio版本。<br>

注意，该是安装Windows驱动，而不是安装Linux驱动，在Windows下安装驱动后，会自动将驱动以_libcuda.so_的形式集成至WSL2中，因此<strong>切勿在WSL Linux中重复安装驱动</strong>。</p>]]></description></item><item><title>Hyper-V做port forwarding</title><link>https://example.com/hyper-v%E5%81%9Aport-forwarding/</link><pubDate>Fri, 08 Sep 2023 21:00:00 +0000</pubDate><author>pigLoveRabbit</author><guid>https://example.com/hyper-v%E5%81%9Aport-forwarding/</guid><description><![CDATA[<h2 id="创建-nat-虚拟网络">创建 NAT 虚拟网络</h2>
<p>要用到一些PowerShell命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">New-VMSwitch -SwitchName &#34;new&#34; -SwitchType Internal
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">New-NetIPAddress -IPAddress 192.168.0.1 -PrefixLength 24 -InterfaceAlias &#34;vEthernet (new)&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">New-NetNat -Name MyNATnetwork -InternalIPInterfaceAddressPrefix 192.168.0.0/24
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>New-VMSwitch</code>  新建了一个内部的交换机<br>
<code>New-NetIPAddress</code> 设置了网卡的ip<br>
<code>New-NetNat</code> 设定了子网</p>]]></description></item><item><title>Blender常用操作</title><link>https://example.com/blender%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</link><pubDate>Thu, 20 Jul 2023 19:00:00 +0000</pubDate><author>pigLoveRabbit</author><guid>https://example.com/blender%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</guid><description><![CDATA[<p></p>
<!-- more -->
<h5 id="查看顶点面法向量">查看顶点/面法向量</h5>
<p>左上角下拉框选择<code>编辑模式</code>，在右边3个Tab中选择<code>面模式</code>
<br>
然后点overlays下拉箭头，就能看到normal的选项了<br>
<br>
第一个Tab就是顶点法向，第三个Tab就是面法向。</p>]]></description></item><item><title>WebGL Shader</title><link>https://example.com/webgl-shader/</link><pubDate>Sun, 02 Jul 2023 16:00:00 +0000</pubDate><author>pigLoveRabbit</author><guid>https://example.com/webgl-shader/</guid><description><![CDATA[<h5 id="顶点着色器">顶点着色器</h5>
<p>vertex.glsl</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">varying</span> <span class="n">vec3</span> <span class="n">vPosition</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">vPosition</span> <span class="o">=</span> <span class="n">position</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">MVP</span>
</span></span><span class="line"><span class="cl">    <span class="n">vec4</span> <span class="n">modelViewPosition</span> <span class="o">=</span> <span class="n">modelViewMatrix</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span> <span class="n">position</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">vec4</span> <span class="n">projectedPosition</span> <span class="o">=</span> <span class="n">projectionMatrix</span> <span class="o">*</span> <span class="n">modelViewPosition</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">projectedPosition</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="片段着色器">片段着色器</h5>
<p>fragment.glsl</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">varying</span> <span class="n">vec3</span> <span class="n">vPosition</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">gl_FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">vPosition</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="效果">效果</h4>
<p>用了PlaneGeometry</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">meshes</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">geometry</span> <span class="o">=</span> <span class="n">new</span> <span class="n">THREE</span><span class="o">.</span><span class="n">PlaneGeometry</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">material</span> <span class="o">=</span> <span class="n">new</span> <span class="n">THREE</span><span class="o">.</span><span class="n">ShaderMaterial</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">  <span class="n">vertexShader</span><span class="p">:</span> <span class="n">vertexShader</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">fragmentShader</span><span class="p">:</span> <span class="n">fragmentShader</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p></p>]]></description></item><item><title>OpenGL中旋转矩阵</title><link>https://example.com/opengl_matrix/</link><pubDate>Tue, 21 Mar 2023 11:00:00 +0000</pubDate><author>pigLoveRabbit</author><guid>https://example.com/opengl_matrix/</guid><description><![CDATA[<h2 id="旋转矩阵">旋转矩阵</h2>
<p>首先要说明的是，左右手旋转矩阵是不一样的，DirectX中是左手坐标系，而OpenGL用的是<strong>右手坐标系</strong>，这里给出的旋转矩阵也是基于右手坐标系的</p>]]></description></item><item><title>wxWidgets使用</title><link>https://example.com/wxwidgets%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 15 Aug 2022 09:30:00 +0000</pubDate><author>pigLoveRabbit</author><guid>https://example.com/wxwidgets%E4%BD%BF%E7%94%A8/</guid><description><![CDATA[<p></p>
<!-- more -->
<h2 id="源码编译安装">源码编译安装</h2>
<p>前往wxWidgets<a href="https://www.wxwidgets.org/downloads/" target="_blank" rel="noopener noreffer ">官网</a>，下载wxWidgets</p>
<p></p>
<p>打开<code>Developer Command Prompt for VS 2022</code>工具，进入 <code>build\msw</code> 目录，编译</p>]]></description></item></channel></rss>